use bip39::{Language, Mnemonic};
use rand;
use thiserror::Error;

#[derive(Debug, Error)]
pub enum MnemError {
    #[error("Invalid entropy length: {0}. Only 12 and 24 are supported.")]
    Length(usize),

    #[error(transparent)]
    MnemonicError(#[from] bip39::Error),
}

// Mnemonic phrase struct
#[derive(Debug)]
pub struct MnemonicWords {
    pub props_words: Mnemonic,
    pub props_legacy: bool,
}

/// Returns a Mnemonic.
///
/// # Arguments
///
/// * `length` - usize length of menwmonic word list (Entropy Length). Only
///              supports lengths of 12 and 24.
///
impl MnemonicWords {
    pub fn generate(length: usize) -> Result<MnemonicWords, MnemError> {
        let mut rng = rand::thread_rng();

        let words = match length {
            12 | 24 => {
                let words = Mnemonic::generate_in_with(&mut rng, Language::English, length).map_err(MnemError::MnemonicError)?;
                words
            }

            _ =>  {
               return Err(MnemError::Length(length));
            }
        };
        
        Ok(MnemonicWords {
            props_words: words,
            props_legacy: false,
        })
    }

    /// Returns a new random 12-word mnemonic from the BIP-39
    /// standard English word list.
    ///
    pub fn generate_12() -> Result<MnemonicWords, MnemError> {
        let mnemonic = MnemonicWords::generate(12)?;
        Ok(mnemonic)
    }

    /// Returns a new random 24-word mnemonic from the BIP-39
    /// standard English word list.
    pub fn generate_24() -> Result<MnemonicWords, MnemError> {
        let mnemonic = MnemonicWords::generate(24)?;
        Ok(mnemonic)
    }

    // Construct a mnemonic from a list of words. Handles 12, 22 (legacy), and 24 words.
    //
    // An exception of UnknownWord will be thrown if the mnemonic
    // contains unknown words or fails the checksum. An invalid mnemonic
    // can still be used to create private keys, the exception will
    // contain the failing mnemonic in case you wish to ignore the
    // validation error and continue.
    //
    // Returns Mnemonic
    //
    // # Arguments
    // 
    // * `words` - List of strings
    //
    //pub fn from_words(words: [u16]) -> Result<Mnemonic, PhraseError>{
    //    Ok(Mnemonic{words: words, lang: Language::English})
    //}

    /// Returns Mnemonic.
    ///
    pub fn verify(&self){
        // Validate that this is a valid BIP-39 mnemonic
        // as generated by BIP-39's rules.

        // Technically, invalid mnemonics can still be used to generate valid private keys,
        // but if they became invalid due to user error then it will be difficult for the user
        // to tell the difference unless they compare the generated keys.

        // During validation, the following conditions are checked in order

        //  1) 24 or 12 words

        //  2) All strings in {@link this.words} exist in the BIP-39
        //     standard English word list (no normalization is done)

        //  3) The calculated checksum for the mnemonic equals the
        //     checksum encoded in the mnemonic

        if self.props_legacy {

        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate() -> Result<(), MnemError> {
        // Can't really test generate because it'll alwats be random,
        // but can test props legacy to make sure we get false

        // Maybe there's a way, I dunno
        let generate_test = MnemonicWords::generate(12)?;
        println!("Generate Test: {:?}", generate_test);
        let mut rng = rand::thread_rng();

        let bip_gen = Mnemonic::generate_in_with(&mut rng, Language::English, 24)?;
        println!("Bip Test: {:?}", bip_gen);

        assert_ne!(true, generate_test.props_legacy);
        Ok(())
    }

    #[test]
    fn test_generate_12() -> Result<(), MnemError> {
        let generate_12 = MnemonicWords::generate_12()?;
        println!("{:?}", generate_12.props_words);

        assert_ne!(true, generate_12.props_legacy);
        Ok(())
    }

    #[test]
    fn test_generate_24() -> Result<(), MnemError> {
        let generate_24 = MnemonicWords::generate_24()?;
        println!("{:?}", generate_24.props_words);

        assert_ne!(true, generate_24.props_legacy);
        Ok(())
    }
}
